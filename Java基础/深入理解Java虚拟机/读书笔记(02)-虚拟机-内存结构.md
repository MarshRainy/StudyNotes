# 自动内存管理机制

---

# Java内存区域与内存溢出异常

既然把内存交给了别人管理, 出错处理就会异常艰难...

## 运行时数据区域

运行时数据区包括: 
-   线程共享:方法区(Method Area), 堆(Heap), 
-   线程隔离:虚拟机栈(VM Stack), 本地方法栈(Native Method Stack), 程序计数器(Program Counter Register)
-   外部为执行引擎和本地库接口

### 程序计数器

-   一块较小的内存空间, 指向当前执行的行号
-   分支, 循环, 异常, 跳转, 线程恢复, 都要依赖此计数器
-   线程私有
-   如果正在执行Java代码, 指向虚拟机字节指令地址; 如果正在执行nativedaima, 为空;
-   规范中唯一没指定任何OutOfMemoryError情况的区域

### 虚拟机栈

-   线程私有, 生命周期同线程
-   每个方法执行时都会创建栈帧(Stack Frame), 
    -   存储局部变量, 操作数栈, 动态链接, 方法出口等. 
    -   每个方法开始到完成, 都会在虚拟机栈有栈帧入栈出栈操作.
-   最常说的栈内存, 就是这里...
-   局部变量表:
    -   基本数据类型
    -   对象引用(reference类型)
    -   returnAddress类型
-   方法运行期间, 不会改变局部变量表大小
-   两种异常:
    -   请求栈深度不够: StackOverflowError
    -   允许动态扩展, 但无内存: OutOfMemoryError

### 本地方法栈

-   为虚拟机用的Native方法服务.
-   可自由实现
-   有地虚拟机将他和虚拟机栈合并了(Sun HotSpot 虚拟机)
-   也会抛出StackOverflowError和OutOfMemoryError

### 堆

-   线程共享
-   规范描述: 所有对象实例以及数组都要在堆上实现. 现在不那么绝对了:JIT编辑器发展, 逃逸分析技术, 栈上分配, 标量替换优化...
-   为GC回收管理的主要区域(垃圾堆..)
    -   内存回收:新生代和老生代
    -   细致:Eden空间, From Survivor 空间, To Survivor 空间
    -   内存分配角度: 多个线程私有的分配缓冲区(TLAB)
-   存的都是对象实例
-   分区目的是为了更好的回收
-   堆只要逻辑连续, 可固定可扩展(扩展:-Xmx,-Xms)
-   堆无法扩展:OutOFMemoryError

### 方法区

-   线程共享
-   存储虚拟机加载的类信息, 常亮, 静态变量, 即时编译器编译后的代码, 等
-   别名(Non-Heap), 
-   另一种称呼:永久代(Permanent Generation), 但并不等价, 只是HotSpot虚拟机将GC扩展至方法区, 用永久代来实现方法区而已. 永久代实现此不是个好主意, 更容易出现内存溢出问题. 现在正逐步移除永久代...(JEP 122)
-   规范: 可以选择不做垃圾回收
-   回收: 针对常量池和类卸载, 虽然效果不好, 但有必要
-   无法扩展: OutOfMemoryError

### 运行时常量池

-   方法区的一部分, 存放编译期生成的字面量和符号引用
-   相比于Class文件, 有一定的动态性. 如:String类的intern()方法

### 直接内存

-   不是虚拟机运行时数据区的一部分, 也不是规范中定义的内存区域.
-   Native函数直接分配堆外内存, 堆中使用DirectByteBuffer对象作为这块内存的引用操作.
-   会出现OutOfMemoryError

## HotSpot虚拟机对象探秘

使用一个代表性的虚拟机

### 对象的创建

仅限于普通的Java对象(不包括数据和Class对象)

-   new 类
-   在常量池找类的符号引用, 检查这个类是否已加载,解析,初始化过. 如果没有, 先加载.
-   分配内存, 大小确定
    -   方案:
        -   堆规整: 指针碰撞(bump the pointer)
        -   堆不规整: 空闲列表(Free List)
        -   堆是否规整取决于GC是否有压缩整理功能.
    -   如果是指针碰撞, 要考虑高并发下指针的赋值
        -   方案1: 动作同步:保证更新的原子性
        -   方案2: 本地线程分配缓冲(TLAB): 只有TLAB用完并要求分配新的TLAB才需要同步锁定.(-XX:+/-UseTLAB) 
-   初始化0值
-   针对对象的必要设置(对象头)
    -   哪个类的实例
    -   找到类的元数据信息
    -   对象的Hash码
    -   GC分代年龄
-   由invokespecial指令决定是否执行<init>方法

### 对象的内存分布

HotSpot虚拟机中, 对象在内存中:对象头(Header), 实例数据(Instance Data), 对齐填充(Padding)

对象头:
-   存储自身运行时的数据
    -   如Hash码, GC分代年龄, 锁状态标识, 线程持有的锁, 偏向线程ID, 时间戳 等. 
    -   在32位机上为32bit, 64位机上为64bit, 官方成为Mark Word
-   另一部分存储类型指针
    -   对象指向它类元数据的指针, 但不是所有虚拟机都这么做. 
-   如果是Java数据, 还要保存数组长度

实例数据:
-   存储有效信息, 无论父类继承还是在子类中定义.
-   存储顺序受虚拟机分配策略参数和字段在Java源码中定义顺序影响

对齐填充
-   非必然存在
-   只是HotSpot虚拟机要求内存寻址为8字节

### 对象的访问定位

问题: reference类型只规定了一个指向对象的引用, 并没有明确一种方法如何定位访问堆中对象的具体位置. 目前主流的访问方式有句柄和直接指针两种类型

句柄:
-   Java堆中分配内存作为句柄池
-   reference中存储的是对象的句柄地址
-   句柄中包含了对象的实例数据与类型数据的具体的地址信息

直接指针:
-   reference中直接指向对象地址

优劣:
-   对于句柄: 对象在GC时, 发生移动, 只需修改句柄中的指针, reference本身不需要修改
-   直接指针执行快, 少了一层指针定位

## OOM异常(OutOfMemoryError)

dump文件: 参数-XX:+HeapDumpOnOutOfMemoryError

### 堆溢出

一般提示: java.lang.OutOfMemoryError, 随后提示: Java Heap Space

一般通过遗憾镜像分析工具(如 Eclipse Memory Analyzer)对Dump出来的堆转储快照分析, 是否全是必要存在的, 已区别是内存泄漏(Memory Leak)还是内存溢出(Memory Overflow)

内存泄漏: 通过引用链来找出不能回收的原因
内存溢出: 是否可调大(-Xmx与-Xms), 或查看大数据生命周期过长, 是否可以优化代码

### 虚拟机栈和本地方法栈溢出

HotSpot不区分本地方法栈, 所以参数-Xoss(设置本地方法栈大小)没用. 栈容量有-Xss决定. 

单线程, 无限递归调用, 内存无法分配时, 抛出SOF. 

多线程, 创建线程时因无法分配堆栈空间, 抛出OOM.

多线程下, 由于内存资源有限, 为了提高线程数, 适当减少栈空间是可行的.

### 方法区和运行时常量池溢出

String.intern()是一个Native方法, 如果常量池中有字符串, 返回引用, 否则将字符串放入常量池, 返回引用. JDK6及以前, 会内存溢出, 但JDK7不怎么会.

可以通过 -XX:PermSize 和 -XX:MaxPermSize 限制方法区大小. 

报错: java.lang.OutOfMemoryError 随后:PermGen Space

无限向常量池写数据会溢出
无限动态创建类也会溢出, 如CGLib技术
(动态类这种东西貌似好麻烦的样子...)

### 本机直接内存异常

可以通过 -XX:MaxDirectMemorySize 指定. 

测试方法: Unsafe实例进行内存分配(不懂)

此类异常不容易找出. 如果程序中直接或间接使用了NIO, 可以考虑是不是这方面的原因

