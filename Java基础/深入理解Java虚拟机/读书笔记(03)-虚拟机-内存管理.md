# 自动内存管理机制

---

# 垃圾收集器与内存分配策略

好玩的话: Java和C++之间有一堵由内存动态分配和垃圾收集技术围成的高墙, 墙外面的人想进去, 墙里面的人却想出来.

栈中的数据: 基本固定了, 没必要回收...
堆中的数据动态创建, 需要去回收...

## 对象死了吗

### 引用计数算法

-   对对象添加一个引用计数器, 为0表示没人引用, 不为0表示有人引用
-   很对语言都在用, java很少用, 因为避免不了循环引用

### 可达性分析算法(Reachability Analysis)

-   相对于GC-Roots不可达, 就认为可回收
-   GC-Roots
    -   虚拟机栈中引用的对象
    -   方法区中类静态属性引用的对象
    -   方法区中常量引用的对象
    -   本地方法栈中JNI(Native方法)引用的对象

### 再谈引用

关于引用的对象实例, 如果没人引用, 就会被回收, 这种方式, 并不灵活

JDK1.2后, 对引用的概念进行了扩充, 包含 强引用, 软引用, 弱引用, 虚引用. 
-   强引用: 程序内普遍存在, 主要强引用还在, 就不会回收.
-   软引用: 有用但是不是必须的对象. 将内存溢出的时候, 会将这些对象二次回收, 看是否还有足够的内存. 提供SoftReference类实现软引用
-   弱引用: 描述非必须的对象. 其关联的对象只能存活到下一次GC回收. 无论内存是否够, 都会回收弱引用. 提供WeakReference类
-   虚引用: 也成幽灵引用或幻影引用. 目的只是为了在此对象被回收时, 接收一个系统通知. 提供PhantomReference

### 生存还是死亡

-   算法中分析出来的不可达的对象, 并非立即死亡, 暂时处于缓刑状态, 要宣告死亡, 需要经过两次标记
-   当发现此对象没被引用, 第一次标记, 并进行筛选, 筛选条件为是否需要执行finalize()方法. 
-   待执行finalize()方法的对象, 将放入F-Queue队列中, 待执行. 执行由虚拟机触发, 并不保证一定完成. 
-   如果在finalize方法中拯救了自己, 第二次标记会将其移出回收站, 可以存活.

finalize方法只会执行一次. 尽量避免使用, 代价大, 不确定性打, 无法保证调用顺序, 最好忘掉它.

### 回收方法区

-   回收方法区效率不高
-   常量回收: 无引用
-   类回收: 
    -   类所有实例已经回收, 
    -   类的ClassLoader已经被回收
    -   对应的Class对象没有在任何地方被引用. 无法通过任何地方反射获得该类的方法.
-   可以回收类, 但不一定回收. 是否回收, 使用 -Xnoclassgc 
-   大量使用反射, 动态代理, CGLib 等 ByteCode框架, 动态生成JSP, OSGi, 这类频繁自定义ClassLoader的场景需要虚拟机具备类卸载能力, 保证方法区不溢出.

## 垃圾收集算法

### 标记清除算法

-   标记判定, 然后清除
-   问题: 
    -   效率不高: 标记清除效率不高
    -   碎片问题: 产生大量碎片

### 复制算法

-   内存分成两块, gc时, 将可用复制到另一块, 这一块全清.
-   实现简单, 运行高效
-   问题: 
    -   因为算法, 内存容量减半.
    -   存活率较高, 导致复制效率变低

由于存活率平均在0.02, 所以可用性较高
此算法, 很多商业虚拟机采用, 大约为0.8Eden区, 两个Survivor区, 只有0.1区域被浪费
但不能保证survivor区完全够用, 需要老年代进行分配担保

### 标记整理算法

-   标记后, 将后面的可用前移, 清理之后所有的区域

### 分代收集算法

根据对象的存活周期, 将内存划分为几块, 
-   新生代: 大批对象死去, 所以采用复制算法,
-   老年代: 存活率较高, 采用标记清理或标记整理算法

## HotSpot的算法实现

### 枚举根节点

-   GC-Roots节点主要分布在全局性的引用(常量或类静态属性)与执行上下文(栈帧中的本地变量)
-   逐个检查节点会很耗时
-   遍历需要根节点的一致性. 即在遍历时不能发生变化, 所以需要停顿所有Java线程.

-   当系统停顿下后, 系统是可以知道对象引用存在哪里. 
-   HotSpot使用成为OopMap的结构来保存对象内哪个偏移量保存的是哪种类型的数据

### 安全点

-   起因: 按理, 每次引用关系的变化都会导致OopMap的数据的变化, 但这样会导致占用大量额外空间, GC成本过高
-   解决: 只在特定的时间记录OopMap, 这个特定的时间就是安全点(SafePoint).
-   要求: 不能少, 不能多, 以"可以让程序长时间执行"为特征, 如: 调用, 循环, 异常跳转 等, 才会生成安全点.

-   问题: 如何让所有程序在同一时间点到达安全点进行GC.
-   抢先式中断(Preemptive Suspension): 先中断所有线程, 发现有线程不在安全点再恢复, 直到跑到安全点. 几乎没有虚拟机用此法处理GC事件
-   主动中断(Voluntary Suspension): GC时先设置标志位, 所有线程都会轮询此标志位. 发现需要中断自行中断. 

### 安全区域

-   问题:　当线程处于休眠状态时, 无法主动走到安全点, 典型情况如: Sleep状态或 Blocked状态. 
-   安全区域(SafeRegion): 引用关系不会发生变化的区域, 
-   线程可以随时进入安全区域, 出安全区域需要等待可以离开安全区域的信号.
-   JVM要发起GC时, 会跳过标示为安全区域的线程

## GC(垃圾收集器)

JDK1.7U14之后的虚拟机:
-   年轻代: Serial, ParNew, Parallel Seavenge
-   老年代: CMS, Serial Old(MSC), Parallel Old
-   G1: 两边都能用

可搭配关系:
-   CMS和MSC可搭, 并可与Serial或PartNew搭
-   Parallel Seavenge可与 MSC或 Parallel Old 搭

### Serial收集器

-   新生代
-   单线程
-   复制算法
-   Stop the world 
-   有几率耗时长
-   Client模式下, 默认新生代收集器
-   单线程环境下简单高效
-   内存小的话, 收集时间可控制在几十ms到百ms

### ParNew收集器

-   新生代
-   Serial的多线程版本
-   多数Server模式下虚拟机首选新生代收集器
-   能配合CMS收集器(老年代)
-   无法与Parallel Scavenge配合
-   使用 -XX:+UseConcMarkSweepGC的默认新生代收集器, 也可用 -XX:+UseParNewGC 指定
-   单线程下不一定比Serial厉害

### Paralle Scavenge收集器

-   新生代
-   复制算法
-   关注: 可控制的吞吐量(CPU运行用户代码/CPU运行总时间)
-   主要用于计算过多但交互不多的情况
-   -XX:MaxGCPauseMillis 最大GC时间,尽量在此时间内; -XX:GCTimeRatio 吞吐量的倒数
-   -XX:+UseAdaptiveSizePolicy 自适应参数调节

### Serial Old收集器

-   老年代
-   单线程
-   标记-整理算法
-   主要给Client使用
-   Server中, 搭配Paralle Scavenge使用, 或作为CMS的后备预案

### Parallel Old 收集器

-   老年代
-   标记-整理算法
-   JDK6之后才出现, 配合Paralle Scavenge使用, 为了提高整体效率.

### CMS收集器

-   老年代
-   标记-清除算法
-   目的: 减少停顿时间
-   流程:
    -   初始标记: 单线程, 所有线程停止
    -   并发标记: 单线程, 并发
    -   重新标记: 多线程, 所有线程停止
    -   并发清除: 单线程, 并发
-   初始标记, 只标记GC-Roots直接关联的对象, 并发标记才向下跟踪, 重新标记是对并发标记的修正, 耗时比并发标记短的多.
-   缺点:
    -   对CPU资源敏感
    -   无法处理浮动垃圾(Floating Garbage), 所以不能再内存快满时调用, 应更提前调用.如果没有提前调用导致GC中内存不够, 会触发一次FullGc, 性能降低更大.
    -   存在碎片. 必要情况下要进行整理.

### G1收集器

特性:

-   JDK7u4之后商用
-   目的替换CMS
-   服务端收集器
-   特点
    -   并行与并发
    -   独自管多分代
    -   整体看, 基于标记-整理算法, 局部上看基于复制算法.
    -   可预测停顿时间
-   内存: 分为多个Region, 新生代与老年代不再物理隔离, 而是多个Region的集合.
-   针对各Region进行回收效益评估, 优先回收效益高的Region

问题:

-   问题: Region之间相互关联, 又要避免全堆扫描
-   处理: 每个Region都维护一个Remembered Set保存对外的引用, 从而避免全堆扫描.

流程

-   初始标记
-   并发标记
-   最终标记
-   筛选回收

不确定其性能如何...

### 理解Gc日志

### 垃圾收集器参数总结...

## 内存分配与回收策略

上文提到的都是如何回收内存, 下面说的是如何分配内存

-   大方向: 堆上分配(可能经JIT编译后拆成基本类型间接在栈上分配)
-   对象主要分配在Eden区, 如果启动本地线程分配缓冲, 将优先在TLAB上分配. 
-   少数情况直接分配在老年代中

### 对象优先在Eden分配

-   大多数情况, 对象在新生代中分配, 当新生代没有足够空间时, 虚拟机将发起一次Minor GC.
-   Minor GC后发现无法将Eden区的对象全部放入Survivor区时, 将提前将数据放入老年代(分配担保机制)

### 大对象直接进入老年代

-   大对象: 需要大量连续内存空间的Java对象, 最典型的是很长的字符串和数组.
-   对Java虚拟机讲, 最悲剧的是朝生夕灭的大对象. 经常出现大对象会导致内存还有不少空间就提前出发垃圾收集.
-   目的: 避免Eden区及两个Survivor区发生大量内存复制
-   参数PretenureSizeThreshold控制多大算大对象. 但是只对 Serial 和 ParNew 有效. 

### 长期存活的对象将进入老年代

-   如果对象经过一次 Minor GC 后依旧存活, 那么年龄+1, 默认15岁就能进入老年代了. 参数为 -XX:MaxTenuringThreshold. 

### 动态对象年龄判定

-   同年龄所有对象大小总和大于Survivor空间的一半, 年龄大于等于该年龄的对象直接进入老年代. 

### 空间分配担保

-   Minor GC 之前会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间, 成立则安全
-   如果不成立, 则查看HandelPromotionFailure设置值是否允许担保失败
-   如果允许担保失败, 检查老年代最大可用连续空间是否大于历次晋升到老年代的数据的平均大小, 如果大于, 可以尝试Minor GC.
-   如果小于, 或不允许冒险, 则要Full GC
-   是否允许担保失败 在 JDK6u24后没用了