# 自动内存管理机制

---

# 调优案例分析与实战

## 案例分析

### 高性能硬件上的程序部署策略

条件: 
-   性能: 4核CPU, 16G内存, 64位CentOS, Resin作为Web服务器 
-   功能: 在线文档类型网站
-   数据: 150KPV/天

初始:
-   堆固定12G
-   Server模式, 吞吐量优先收集器

问题: 
-   文档序列化产生大对象, 直接进入老年代, 没有在Minor GC 中清理掉.
-   Full GC, 12G内存, 要14s, 明显卡顿

分析:
-   对于用户交互性强, 对停顿时间敏感的系统, 可以给虚拟机分配超大堆的前提是可以控制Full GC的频率很低, 低到不影响用户使用. 
-   控制Full GC频率的关键是, 不能有批量的, 长时间生存的大对象生成, 从而保证老年代稳定. 
-   64位JDK管理大内存的问题
    -   内存回收时间过长
    -   现阶段, 64位JDK性能不如32位JDK
    -   堆转储文件过大, 几乎无法分析
    -   程序过大, 相比32位
-   32位集群的问题:
    -   同时访问磁盘文件的竞争
    -   很难高效利用某些资源池
    -   节点要受32位的限制

调整后:
-   5个32位JDK逻辑群, 1.5G堆
-   Apache服务作为前端负载均衡访问门户
-   CMS收集器进行垃圾回收

### 集群间同步导致的内存溢出

条件:
-   两台2个CPU,8G内存的HP小型机, 
-   服务器是WebLogic9.2, 
-   每台机器启动了3个WebLogic实例, 构成6节点亲和式集群.

要求:
-   一部分数据要求各个节点间共享

问题: 
-   共享数据构建在数据库, 读写竞争频繁
-   使用JBossCache构建全局缓存, 出现多次内存溢出

分析:
-   溢出后, 看到大量NAKACK文件

结果:
-   JBossCache这类的共享缓存, 不应有过频繁的写操作, 会产生较大的网络开销.

### 堆外内存导致的溢出错误

条件:
-   CometD 1.1.1 作为服务端推动框架, 
-   服务器是Jetty 7.1.4
-   普通PC机, I5CPU, 4G内存, 32位 

要求:
-   基于B/S的电子考试系统
-   客户端实时从服务端接收考试数据
-   逆向AJAX技术

问题
-   内存溢出, 
-   虚拟机内存一切异常
-   压力不大

分析:
-   虚拟机虽然会对直接内存进行回收, 但只是Full GC顺带的事情, 
-   当直接内存没空间, 可能会通知虚拟机GC, 但如果虚拟机不理它, 就会内存不足
-   CometD框架使用大量NIO操作

注意:受到系统内存影响的地方:
-   直接内存
-   线程堆栈
-   Socket缓存区, 每个链接都有Receive和Send两个缓存区, 分别大约37K和25K
-   JNI代码: JNI调用本地库, 本地库使用的内存不在堆中
-   虚拟机和GC: 虚拟机和GC的执行都需要一定内存

### 外部命令导致系统缓慢

条件:
-   4个CPU, Solaris 10 系统, 中间件为GlassFish服务器

问题:
-   CPU占用极高, 大部分资源占用的不是应用系统本身.

原因:
-   每个用户的请求都需要执行一个外部的shell脚本, 通过Java的Runtime.getRuntime().exex()调用的. 这种调用对系统负担很重.

### 服务器JVM进程崩溃

条件:
-   基于B/S的MIS系统, 2个CPU, 8G内存的HP系统, 服务WebLogic9.2

问题:
-   集群节点的虚拟机进程自动关闭, 关闭前产生大量相同的异常: Connection reset

原因:
-   请求响应采用了异步的做法, 因为两边的处理速度不对等, 时间长了就积累了大量的Web服务没有调用完成. 导致等待的线程和Socket链接越来越多. 

解决:
-   异步调用改为生产者/消费者模式的消息队列.

### 不恰当数据结构导致内存占用过大

条件:
-   后台RPC服务器, 64位虚拟机, -Xms4g -Xmx8g -Xmn1g, ParNew+CMS收集器.

问题:
-   每10分钟加载一个80MB的数据文件到内存进行数据分析. 这些数据会形成超过100w个HashMap, MinorGC会产生500ms停顿. 

分析:
-   Eden区很快占满, 引发MinorGC, 但GC的时候按复制算法, 而Eden区全部存活导致复制效率低. 

解决:
-   GC调优: 治标不治本: -XX:SurvivorRatio=65535, -XX:MaxTenuringThreshold=0 或 -XX:+AlwaysThreshold. 新生代中存活的对象第一次MinorGC后立即进入老生代. 但副作用很大.
-   空间效率: HashMap<Long,Long> 效率大约18%...

### 由Windows虚拟内存导致的长时间停顿

条件: 
-   带心跳检测功能的GUI桌面程序, 15s发一次心跳, 30s没返回认为对方程序以断开. 

问题:
-   偶尔心跳检测误报.
-   程序偶尔会有一分钟的停顿

分析:
-   确认停顿由GC导致, 偶尔有一分钟停顿的GC
-   真正执行GC时间不长, 但是从准备GC到开始GC的时间很长.
-   当最小化的时候, 资源管理器中的内存大幅度减少, 但是虚拟机内存没变, 说明工作内存自动交换到磁盘的页面文件中. 恢复内存导致不正常的GC停顿

解决:
-   Java的GUI程序存在这些问题, 可以写参数避免
-   -Dsun.awt.keepWorkingSetOnMinimize=true

## Eclipse 调优

大约的调优的感觉:
-   看看因为JDK是否能带来一定的性能变化
-   针对各项运行时间, 逐个进行调优
-   调整内存选项, 更适合GC
-   调整GC选项, 选用合适的收集器

有时间实战下...